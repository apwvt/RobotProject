import javafx.beans.InvalidationListener
import javafx.beans.Observable
import kotlinx.coroutines.*
import javax.bluetooth.LocalDevice
import javax.bluetooth.ServiceRecord
import javax.microedition.io.Connector
import javax.microedition.io.StreamConnection
import javax.microedition.io.StreamConnectionNotifier

/**
 * Bluetooth serial communication wrapper.
 *
 * A JSR-82 bluetooth serial tunnel between this device and a remote bluetooth device.
 * This project uses BlueCove 2.1.1 as its JSR-82 implementation.  Due to limitations within
 * the bluetooth architecture, it may take up to 30s to establish communication with a remote
 * bluetooth device; therefore, this class will perform the setup work in a separate thread and
 * is Observeable for completion.
 *
 * @exception IllegalStateException     This object may throw an [IllegalStateException] at construction
 *                                      if the Bluecove library fails to initialize.  This object should
 *                                      not be used in this case.
 *
 * @property connection     The Bluetooth connection stream that this object is currently maintaining, or
 *                          null if no connection is ready.  The connection in this property may or may
 *                          not be active; all code using it should catch any IOExceptions that may
 *                          arise and call closeConnection() on this object in that case.
 *
 * @property isConnected    True if this object is currently managing a connection.  As above, there is no
 *                          guarantee that anything is listening on the other side, so any exceptions
 *                          generated by the connection are grounds for a closeConnection() call.
 *
 * @property isConnecting   True if this object is currently seeking a connection.  The connection
 *                          property is never ready to use while this is true.
 *
 * @author Alexander Wilson
 */
class BluetoothSerial: Observable {
    companion object {
        @ObsoleteCoroutinesApi
        private val connectionContext = newFixedThreadPoolContext(2, "BTConnectPool")
    }

    private val observers = arrayListOf<InvalidationListener>()
    /**
     * Removes the given [listener] from the notification list for
     * this object.  See Observable.removeListener().
     */
    override fun removeListener(listener: InvalidationListener?) {
        observers.remove(listener)
    }

    /**
     * Adds a given [listener] to the notification list for
     * this object.  See Observable.addListener().
     */
    override fun addListener(listener: InvalidationListener?) {
        if (listener == null) return
        observers.add(listener)
    }

    private val thisDevice: LocalDevice = LocalDevice.getLocalDevice() ?:
            throw IllegalStateException("Could not create local bluetooth device.")

    private val serviceUrl: String

    private val service: StreamConnectionNotifier
    private val serviceRecord: ServiceRecord

    private var getConnectionJob: Deferred<StreamConnection>? = null

    @ExperimentalCoroutinesApi
    val connection: StreamConnection?
        get() {
            // Without this line, accesses to this property
            // block until the job finishes.
            if (isConnecting) return null
            return getConnectionJob?.getCompleted()
        }

    val isConnected: Boolean
        get() {
            return getConnectionJob?.isCompleted ?: false
        }

    val isConnecting: Boolean
        get() {
            return getConnectionJob?.isActive ?: false
        }

    init {
        serviceUrl = "btspp://localhost:${thisDevice.bluetoothAddress};name=${thisDevice.friendlyName}"
        println("Listening on URL $serviceUrl")

        service = Connector.open(serviceUrl) as StreamConnectionNotifier
        serviceRecord = thisDevice.getRecord(service)
    }

    /**
     * Begin the process of finding a connection.
     *
     * This process may continue indefinitely; its status may be checked
     * with [isConnected] and its result retrieved with [connection].
     *
     * If you're only interested in when this job is done, this class is
     * [Observable] and can be monitored.  This is an invalidating operation.
     */
    @ObsoleteCoroutinesApi
    fun openConnection() {
        val deferred = GlobalScope.async(connectionContext) {
            service.acceptAndOpen()
        }

        //Add a job to notify listeners on completion
        deferred.invokeOnCompletion {
            observers.forEach { it.invalidated(this) }
        }

        getConnectionJob = deferred

        observers.forEach { it.invalidated(this) }
    }

    /**
     * Dispose of the currently managed connection.
     *
     * This may be done at any time after the connection
     * is no longer needed, but should always be done when
     * the managed [connection] produces an exception during
     * normal read/write operations.
     *
     * This is an invalidating operation.
     */
    fun closeConnection() {
        connection?.close()
        getConnectionJob = null

        observers.forEach { it.invalidated(this) }
    }

    /**
     * Send an [array of byte data][data] over the active connection.
     *
     * This function does nothing if no connection is active.
     */
    fun send(data: ByteArray) {
        val thisConnection = connection ?: return

        with (thisConnection.openOutputStream()) {
            write(data)
        }
    }

    /**
     * Read [a number of][bytes] bytes from the active connection.
     *
     * @return  A ByteArray of size [bytes], or size 0 if no connection
     *          is active.
     */
    fun read(bytes: Int): ByteArray {
        val thisConnection = connection ?: return ByteArray(0)

        val arr = ByteArray(bytes)
        with (thisConnection.openInputStream()) {
            read(arr)
        }

        return arr
    }
}